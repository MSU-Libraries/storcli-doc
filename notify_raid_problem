#!/bin/bash
###########################################################
# Script checks StorCLI for non-optimal virtual disks and
# for physical disks that are either offline or bad
#
# On any state deviation, an email notification will be
# sent to the root user of the server.
###########################################################

# Default to controller 0
CID=${1:-0}
# Only allow controller id to be 0 through 9
if [[ ! $CID =~ ^[0-9]$ ]]; then
    echo "ERROR: Controller number out of bounds."
    exit 1
fi

# Desired states enumerated
ALLOWED_VD_STATES=(optl)
ALLOWED_PD_STATES=(onln ugood ghs dhs)
# Default subject message for alerts
MAIL_SUBJECT="WARNING: Hardware RAID problem detected on $HOSTNAME"
# Additional notes to add to alert email
MAIL_NOTES=""

# Flag to set if problem state is found (default to false)
PROBLEM_STATE_FOUND=1

# Possible names of StorCLI binary
STORCLI_BINARIES=( "storcli64" "storcli" )
# If StorCLI binary is not found in path, try these locations also
EXTRA_SEARCH_PATHS=( "/opt/MegaRAID/storcli/" "/usr/local/sbin/" "/usr/local/bin/" )

# StorCLI path
locate_storcli() {
    for BIN in "${STORCLI_BINARIES[@]}"; do
        STORCLI=$( which $BIN )
        FOUND_SCLI=$?
        if [[ $FOUND_SCLI -ne 0 ]]; then
            for EXTRA in "${EXTRA_SEARCH_PATHS[@]}"; do
                if [[ -f "$EXTRA$BIN" && -x "$EXTRA$BIN" ]]; then
                    STORCLI="$EXTRA$BIN"
                    break 2
                fi
            done
        else
            break
        fi
    done
    echo "$STORCLI"
}

STORCLI_PATH=$( locate_storcli )
if [[ -z $STORCLI_PATH ]]; then
    echo "ERROR: Could not find StorCLI binary!"
    exit 1
fi

#############################################
# Check if array contains a given value.
# Comparison is case insensitive.
#  $1 => (string) Global name of array
#  $2 => (string) Value to match in array
# Returns 0 if match is found, 1 otherwise
array_contains_value() {
    local ARRNAME=$1[@]
    local ARR=( "${!ARRNAME}" )
    for ARVAL in "${ARR[@]}"; do
        if [[ ${ARVAL,,} == ${2,,} ]]; then
            return 0
        fi
    done
    return 1
}

# Regular Expression shorthand
RSR="[[:space:]]+"                              # Regex Space Required
RSO="[[:space:]]*"                              # Regex Space Optional
RGR="([[:graph:]]+)"                            # Regex Graph Required
RZR="([[:graph:]]+[[:space:]][[:alpha:]]{2})"   # Regex Size Required (e.g. 45.6 TB)

###########################################################
# Virtual Disks

# Show all virtual disks on controller
VD_COMMAND="${STORCLI_PATH} /c${CID}/vall show"
VD_OUTPUT=$( $VD_COMMAND )
VD_EXIT=$?

# Ensure command ran successfully with expected output
if [[ $VD_EXIT -ne 0 && $VD_EXIT -ne 46 ]]; then
    echo "ERROR: Command exited with code $VD_EXIT: $VD_COMMAND"
    exit 1
fi
VD_HEADER_RE="^DG/VD${RSR}TYPE${RSR}State${RSR}Access${RSR}Consist${RSR}Cache${RSR}Cac${RSR}sCC${RSR}Size${RSR}Name${RSO}$"
VD_ENTRY_RE="^$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RZR$RSR$RGR$RSO$"
VD_MATCHHEADER=1
while read -r LINE; do
    # Ensure we match the header before processing results
    if [[ $LINE =~ $VD_HEADER_RE ]]; then
        VD_MATCHHEADER=0
        continue
    fi

    # Try to parse VD from output only if the header was found
    if [[ $VD_MATCHHEADER -eq 0 && $LINE =~ $VD_ENTRY_RE ]]; then
        if ! array_contains_value ALLOWED_VD_STATES ${BASH_REMATCH[3]}; then
            MAIL_NOTES+="""
Non-optimal virtual drive state (${BASH_REMATCH[3]}) detected for: ${BASH_REMATCH[1]}
"""
            PROBLEM_STATE_FOUND=0
        fi
    fi
done <<< "$VD_OUTPUT"
# Exit with error if no header was matched
if [[ $VD_MATCHHEADER -ne 0 ]]; then
    echo "ERROR: Command did not output a valid header: $VD_COMMAND"
    exit 1
fi

###########################################################
# Physical Disks

# Show all physical disks on controller
PD_COMMAND="${STORCLI_PATH} /c${CID}/eall/sall show"
PD_OUTPUT=$( $PD_COMMAND )
PD_EXIT=$?

# Ensure command ran successfully with expected output
if [[ $PD_EXIT -ne 0 && $PD_EXIT -ne 46 ]]; then
    echo "ERROR: Command exited with code $PD_EXIT: $PD_COMMAND"
    exit 1
fi
PD_HEADER_RE="^EID:Slt${RSR}DID${RSR}State${RSR}DG${RSR}Size${RSR}Intf${RSR}Med${RSR}SED${RSR}PI${RSR}SeSz${RSR}Model${RSR}Sp${RSR}Type${RSO}$"
PD_ENTRY_RE="^$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RZR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSO$"
PD_MATCHHEADER=1
while read -r LINE; do
    # Ensure we match the header before processing results
    if [[ $LINE =~ $PD_HEADER_RE ]]; then
        PD_MATCHHEADER=0
        continue
    fi

    # Try to parse PD from output only if the header was found
    if [[ $PD_MATCHHEADER -eq 0 && $LINE =~ $PD_ENTRY_RE ]]; then
        # Validate PD states are only those allowed
        if ! array_contains_value ALLOWED_PD_STATES ${BASH_REMATCH[3]}; then
            PROBLEM_STATE_FOUND=0
            MAIL_NOTES+="""
Non-optimal physical drive state (${BASH_REMATCH[3]}) detected for: ${BASH_REMATCH[1]}
"""
        fi

        # If a foreign drive is configured, send an alert (might just be a GHS that has been used and copied back)
        if [[ ${BASH_REMATCH[4]} == "F" ]]; then
            PROBLEM_STATE_FOUND=0
            MAIL_SUBJECT="WARNING: Foreign drive group detected in RAID card on $HOSTNAME"
            MAIL_NOTES+="""
A foreign drive group is a drive that has previously been part of a
RAID configuration. One way this can occur is if a hot spare drive
was used. After the copyback, it may retain the temporary DG config
it was part of. In that case, the foreign DG must be cleared and the
drive set as a hot spare once again. See documentation for details.
"""
            break
        fi
    fi
done <<< "$PD_OUTPUT"
# Exit with error if no header was matched
if [[ $PD_MATCHHEADER -ne 0 ]]; then
    echo "ERROR: Command did not output a valid header: $PD_COMMAND"
    exit 1
fi

###########################################################
# Send Notification (if problem state found)

# Email function
# Usage: email "from@example.com" "to@example.com" "Subject" "Message line 1\nMessage line 2"
email() {
    EMAIL_FROM="$1"
    EMAIL_TO="$2"
    EMAIL_SUBJECT="$3"
    EMAIL_MESSAGE="$4"
    EMAIL_HEADERS=$( printf 'From: %s\nTo: %s\nSubject: %s\n' "$EMAIL_FROM" "$EMAIL_TO" "$EMAIL_SUBJECT" )
    printf '%s\n%b\n' "$EMAIL_HEADERS" "$EMAIL_MESSAGE" | $( which sendmail ) -t
}

# Only send notification if a problem was found
if [[ $PROBLEM_STATE_FOUND -eq 0 ]]; then
    HOSTNAMES=( $( hostname -A ) $HOSTNAME localhost )
    TO="root@localhost"
    FROM="root@${HOSTNAMES[0]}"
    SUBJECT="${MAIL_SUBJECT}"
    MESSAGE="""$MAIL_NOTES
A non-optimal RAID state was detected on: $HOSTNAME
Server IP address(es): $( hostname -I )

Virtual Disk check command: $VD_COMMAND
============================================================
$( printf "%s\n"  "${VD_OUTPUT[@]}" )


Physical Disk check command: $PD_COMMAND
============================================================
$( printf "%s\n"  "${PD_OUTPUT[@]}" )
"""

    email "$FROM" "$TO" "$SUBJECT" "$MESSAGE"
fi

