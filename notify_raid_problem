#!/bin/bash
###########################################################
# Script checks StorCLI for non-optimal virtual disks and
# for physical disks that are either offline or bad
#
# On any state deviation, an email notification will be
# sent to the root user of the server.
###########################################################

# Loop through arguments to grab flags
while test $# -gt 0; do
  case "$1" in
    -h|--help)
      echo "notify_raid_problem - Send out an alert if the RAID is unhappy"
      echo "Usage:"
      echo "  ./notify_raid_problem [FLAGS] [CTRLR_ID]"
      echo
      echo "CTRLR_ID:       The integer id of the controler; defaults of 0"
      echo "FLAGS:"
      echo " -h,--help      Show this message"
      echo " -g,--ghs       If Global Hot Spare missing, then send alert"
      exit 0
      ;;
    -g|--ghs)
      REQUIRE_GHS=0
      shift
      ;;
    [[:digit:]]*)
      CID=${1}
      shift
      ;;
    *)
      echo "Unknown argument: ${1}"
      exit 1
      ;;
  esac
done

# Default to controller 0
CID=${CID:-0}
# Only allow controller id to be 0 through 9
if [[ ! $CID =~ ^[0-9]$ ]]; then
    echo "ERROR: Controller number out of bounds."
    exit 1
fi
REQUIRE_GHS=${REQUIRE_GHS:-1}

# Desired states enumerated
ALLOWED_VD_STATES=(optl)
ALLOWED_PD_STATES=(onln ugood ghs dhs)
# Default subject message for alerts
MAIL_SUBJECT="WARNING: Hardware RAID problem detected on $HOSTNAME"
# Additional notes to add to alert email
MAIL_NOTES=""

# Flag to set if problem state is found (default to false)
PROBLEM_STATE_FOUND=1

# Possible names of StorCLI binary
STORCLI_BINARIES=( "storcli64" "storcli" )
# If StorCLI binary is not found in path, try these locations also
EXTRA_SEARCH_PATHS=( "/opt/MegaRAID/storcli/" "/usr/local/sbin/" "/usr/local/bin/" )

# StorCLI path
locate_storcli() {
    for BIN in "${STORCLI_BINARIES[@]}"; do
        STORCLI=$( which $BIN )
        FOUND_SCLI=$?
        if [[ $FOUND_SCLI -ne 0 ]]; then
            for EXTRA in "${EXTRA_SEARCH_PATHS[@]}"; do
                if [[ -f "$EXTRA$BIN" && -x "$EXTRA$BIN" ]]; then
                    STORCLI="$EXTRA$BIN"
                    break 2
                fi
            done
        else
            break
        fi
    done
    echo "$STORCLI"
}

STORCLI_PATH=$( locate_storcli )
if [[ -z $STORCLI_PATH ]]; then
    echo "ERROR: Could not find StorCLI binary!"
    exit 1
fi

#############################################
# Check if array contains a given value.
# Comparison is case insensitive.
#  $1 => (string) Global name of array
#  $2 => (string) Value to match in array
# Returns 0 if match is found, 1 otherwise
array_contains_value() {
    local ARRNAME=$1[@]
    local ARR=( "${!ARRNAME}" )
    for ARVAL in "${ARR[@]}"; do
        if [[ ${ARVAL,,} == ${2,,} ]]; then
            return 0
        fi
    done
    return 1
}

#############################################
# Get progress of either all copyback or rebuild jobs
#  $1 => (string) copyback or rebuild
# Outputs the appropriate printable results
ALLOWED_PROGRESS_JOBS=(copyback rebuild)
job_progress() {
    JOB_TYPE="$1"
    if ! array_contains_value ALLOWED_PROGRESS_JOBS ${JOB_TYPE}; then
        echo "Invalid job progress request: ${JOB_TYPE}"
        exit 1
    fi
    ${STORCLI_PATH} /c${CID}/eall/sall show ${JOB_TYPE} | grep '/c0\|Drive-ID' | grep -v 'Not in progress'
}

# Regular Expression shorthand
RSR="[[:space:]]+"                              # Regex Space Required
RSO="[[:space:]]*"                              # Regex Space Optional
RGR="([[:graph:]]+)"                            # Regex Graph Required
RZR="([[:graph:]]+[[:space:]][[:alpha:]]{2})"   # Regex Size Required (e.g. 45.6 TB)

###########################################################
# Virtual Disks

# Show all virtual disks on controller
VD_COMMAND="${STORCLI_PATH} /c${CID}/vall show"
VD_OUTPUT=$( $VD_COMMAND )
VD_EXIT=$?

# Ensure command ran successfully with expected output
if [[ $VD_EXIT -ne 0 && $VD_EXIT -ne 46 ]]; then
    echo "ERROR: Command exited with code $VD_EXIT: $VD_COMMAND"
    exit 1
fi
VD_HEADER_RE="^DG/VD${RSR}TYPE${RSR}State${RSR}Access${RSR}Consist${RSR}Cache${RSR}Cac${RSR}sCC${RSR}Size${RSR}Name${RSO}$"
VD_ENTRY_RE="^$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RZR$RSR$RGR$RSO$"
VD_MATCHHEADER=1
while read -r LINE; do
    # Ensure we match the header before processing results
    if [[ $LINE =~ $VD_HEADER_RE ]]; then
        VD_MATCHHEADER=0
        continue
    fi

    # Try to parse VD from output only if the header was found
    if [[ $VD_MATCHHEADER -eq 0 && $LINE =~ $VD_ENTRY_RE ]]; then
        if ! array_contains_value ALLOWED_VD_STATES ${BASH_REMATCH[3]}; then
            MAIL_NOTES+="""
Non-optimal virtual drive state (${BASH_REMATCH[3]}) detected for: ${BASH_REMATCH[1]}
"""
            PROBLEM_STATE_FOUND=0
        fi
    fi
done <<< "$VD_OUTPUT"
# Exit with error if no header was matched
if [[ $VD_MATCHHEADER -ne 0 ]]; then
    echo "ERROR: Command did not output a valid header: $VD_COMMAND"
    exit 1
fi

###########################################################
# Physical Disks

# Show all physical disks on controller
PD_COMMAND="${STORCLI_PATH} /c${CID}/eall/sall show"
PD_OUTPUT=$( $PD_COMMAND )
PD_EXIT=$?

# Ensure command ran successfully with expected output
if [[ $PD_EXIT -ne 0 && $PD_EXIT -ne 46 ]]; then
    echo "ERROR: Command exited with code $PD_EXIT: $PD_COMMAND"
    exit 1
fi
PD_HEADER_RE="^EID:Slt${RSR}DID${RSR}State${RSR}DG${RSR}Size${RSR}Intf${RSR}Med${RSR}SED${RSR}PI${RSR}SeSz${RSR}Model${RSR}Sp${RSR}Type${RSO}$"
PD_ENTRY_RE="^$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RZR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSR$RGR$RSO$"
PD_MATCHHEADER=1
PD_FOUND_GHS=1
PD_FOUND_REBUILD=1
PD_FOUND_COPYBACK=1
while read -r LINE; do
    # Ensure we match the header before processing results
    if [[ $LINE =~ $PD_HEADER_RE ]]; then
        PD_MATCHHEADER=0
        continue
    fi

    # Try to parse PD from output only if the header was found
    if [[ $PD_MATCHHEADER -eq 0 && $LINE =~ $PD_ENTRY_RE ]]; then
        # Record if specific PD states are found
        if [[ "${BASH_REMATCH[3],,}" == "ghs" ]]; then
            PD_FOUND_GHS=0
        fi
        if [[ "${BASH_REMATCH[3],,}" == "rbld" ]]; then
            PD_FOUND_REBUILD=0
        fi
        if [[ "${BASH_REMATCH[3],,}" == "cpybck" ]]; then
            PD_FOUND_COPYBACK=0
        fi
        # Validate PD states are only those allowed
        if ! array_contains_value ALLOWED_PD_STATES ${BASH_REMATCH[3]}; then
            PROBLEM_STATE_FOUND=0
            MAIL_NOTES+="""
Non-optimal physical drive state (${BASH_REMATCH[3]}) detected for: ${BASH_REMATCH[1]}
"""
        fi

        # If a foreign drive is configured, send an alert (might just be a GHS that has been used and copied back)
        if [[ ${BASH_REMATCH[4]} == "F" ]]; then
            PROBLEM_STATE_FOUND=0
            MAIL_SUBJECT="WARNING: Foreign drive group detected in RAID card on $HOSTNAME"
            MAIL_NOTES+="""
A foreign drive group is a drive that has previously been part of a
RAID configuration. To reuse drives, any foreign configs must first
be cleared. See documentation for details.
"""
            break
        fi
    fi
done <<< "$PD_OUTPUT"
# Exit with error if no header was matched
if [[ $PD_MATCHHEADER -ne 0 ]]; then
    echo "ERROR: Command did not output a valid header: $PD_COMMAND"
    exit 1
fi

# If the GHS flag was set, send alert when one doesn't exist
if [[ $REQUIRE_GHS -eq 0 && $PD_FOUND_GHS -ne 0 ]]; then
    MAIL_NOTES+="""
No Global Hot Spare drive was found though the command flag requiring one be present was passed.
"""
    PROBLEM_STATE_FOUND=0
fi

# Include progress of rebuild jobs
if [[ $PD_FOUND_REBUILD -eq 0 ]]; then
    PROGRESS_OUT=$( job_progress rebuild )
    MAIL_NOTES+="""
RAID REBUILD JOBS:
${PROGRESS_OUT}
"""
    PROBLEM_STATE_FOUND=0
fi

# Include progress of copyback jobs
if [[ $PD_FOUND_COPYBACK -eq 0 ]]; then
    PROGRESS_OUT=$( job_progress copyback )
    MAIL_NOTES+="""
RAID COPYBACK JOBS:
${PROGRESS_OUT}
"""
    PROBLEM_STATE_FOUND=0
fi

###########################################################
# Send Notification (if problem state found)

# Email function
# Usage: email "from@example.com" "to@example.com" "Subject" "Message line 1\nMessage line 2"
email() {
    EMAIL_FROM="$1"
    EMAIL_TO="$2"
    EMAIL_SUBJECT="$3"
    EMAIL_MESSAGE="$4"
    EMAIL_HEADERS=$( printf 'From: %s\nTo: %s\nSubject: %s\n' "$EMAIL_FROM" "$EMAIL_TO" "$EMAIL_SUBJECT" )
    printf '%s\n%b\n' "$EMAIL_HEADERS" "$EMAIL_MESSAGE" | $( which sendmail ) -t
}

# Only send notification if a problem was found
if [[ $PROBLEM_STATE_FOUND -eq 0 ]]; then
    HOSTNAMES=( $( hostname -A ) $HOSTNAME localhost )
    TO="root@localhost"
    FROM="root@${HOSTNAMES[0]}"
    SUBJECT="${MAIL_SUBJECT}"
    MESSAGE="""$MAIL_NOTES
A non-optimal RAID state was detected on: $HOSTNAME
Server IP address(es): $( hostname -I )

Virtual Disk check command: $VD_COMMAND
============================================================
$( printf "%s\n"  "${VD_OUTPUT[@]}" )


Physical Disk check command: $PD_COMMAND
============================================================
$( printf "%s\n"  "${PD_OUTPUT[@]}" )
"""

    email "$FROM" "$TO" "$SUBJECT" "$MESSAGE"
fi

